<<<<<<< HEAD
import { REVISION } from 'three/webgpu';
import * as TSL from 'three/tsl';

import { VariableDeclaration, Accessor } from './AST.js';
import { isExpression, isPrimitive } from './TranspilerUtils.js';
=======
import * as THREE from 'three';

import { VariableDeclaration, Accessor } from './AST.js';
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9

const opLib = {
	'=': 'assign',
	'+': 'add',
	'-': 'sub',
	'*': 'mul',
	'/': 'div',
	'%': 'remainder',
	'<': 'lessThan',
	'>': 'greaterThan',
	'<=': 'lessThanEqual',
	'>=': 'greaterThanEqual',
	'==': 'equal',
<<<<<<< HEAD
	'!=': 'notEqual',
=======
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9
	'&&': 'and',
	'||': 'or',
	'^^': 'xor',
	'&': 'bitAnd',
	'|': 'bitOr',
	'^': 'bitXor',
	'<<': 'shiftLeft',
	'>>': 'shiftRight',
	'+=': 'addAssign',
	'-=': 'subAssign',
	'*=': 'mulAssign',
	'/=': 'divAssign',
	'%=': 'remainderAssign',
	'^=': 'bitXorAssign',
	'&=': 'bitAndAssign',
	'|=': 'bitOrAssign',
	'<<=': 'shiftLeftAssign',
	'>>=': 'shiftRightAssign'
};

const unaryLib = {
	'+': '', // positive
	'-': 'negate',
	'~': 'bitNot',
	'!': 'not',
	'++': 'increment', // incrementBefore
	'--': 'decrement' // decrementBefore
};

<<<<<<< HEAD
const textureLookupFunctions = [ 'texture', 'texture2D', 'texture3D', 'textureCube', 'textureLod', 'texelFetch', 'textureGrad' ];
=======
const isPrimitive = ( value ) => /^(true|false|-?\d)/.test( value );
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9

class TSLEncoder {

	constructor() {

		this.tab = '';
		this.imports = new Set();
		this.global = new Set();
		this.overloadings = new Map();
		this.iife = false;
<<<<<<< HEAD
		this.reference = false;

		this.block = null;
=======
		this.uniqueNames = false;
		this.reference = false;

		this._currentProperties = {};
		this._lastStatement = null;
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9

	}

	addImport( name ) {

		// import only if it's a node

		name = name.split( '.' )[ 0 ];

<<<<<<< HEAD
		if ( TSL[ name ] !== undefined && this.global.has( name ) === false ) {
=======
		if ( THREE[ name ] !== undefined && this.global.has( name ) === false && this._currentProperties[ name ] === undefined ) {
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9

			this.imports.add( name );

		}

	}

	emitUniform( node ) {

		let code = `const ${ node.name } = `;
<<<<<<< HEAD
		this.global.add( node.name );
=======
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9

		if ( this.reference === true ) {

			this.addImport( 'reference' );

<<<<<<< HEAD
=======
			this.global.add( node.name );

>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9
			//code += `reference( '${ node.name }', '${ node.type }', uniforms )`;

			// legacy
			code += `reference( 'value', '${ node.type }', uniforms[ '${ node.name }' ] )`;

		} else {

<<<<<<< HEAD
			if ( node.type === 'texture' ) {

				this.addImport( 'texture' );

				code += 'texture( /* <THREE.Texture> */ )';

			} else if ( node.type === 'cubeTexture' ) {

				this.addImport( 'cubeTexture' );

				code += 'cubeTexture( /* <THREE.CubeTexture> */ )';

			} else if ( node.type === 'texture3D' ) {

				this.addImport( 'texture3D' );

				code += 'texture3D( /* <THREE.Data3DTexture> */ )';

			} else {

				// default uniform

				this.addImport( 'uniform' );

				code += `uniform( '${ node.type }' )`;

			}
=======
			this.addImport( 'uniform' );

			this.global.add( node.name );

			code += `uniform( '${ node.type }' )`;
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9

		}

		return code;

	}

<<<<<<< HEAD
	emitExpression( node, output = null ) {

		let code;

		if ( node.isAccessor ) {

			if ( node.linker.reference === null ) {

				this.addImport( node.property );

			}
=======
	emitExpression( node ) {

		let code;

		/*@TODO: else if ( node.isVarying ) {

			code = this.emitVarying( node );

		}*/

		if ( node.isAccessor ) {

			this.addImport( node.property );
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9

			code = node.property;

		} else if ( node.isNumber ) {

<<<<<<< HEAD
			code = node.value;
=======
			if ( node.type === 'int' || node.type === 'uint' ) {

				code = node.type + '( ' + node.value + ' )';

				this.addImport( node.type );

			} else {

				code = node.value;

			}
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9

		} else if ( node.isString ) {

			code = '\'' + node.value + '\'';

		} else if ( node.isOperator ) {

			const opFn = opLib[ node.type ] || node.type;

<<<<<<< HEAD
			const left = this.emitExpression( node.left, output );
			const right = this.emitExpression( node.right, output );

			if ( node.isNumericExpression ) {
=======
			const left = this.emitExpression( node.left );
			const right = this.emitExpression( node.right );

			if ( isPrimitive( left ) && isPrimitive( right ) ) {
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9

				return left + ' ' + node.type + ' ' + right;

			}

			if ( isPrimitive( left ) ) {

				code = opFn + '( ' + left + ', ' + right + ' )';

				this.addImport( opFn );

<<<<<<< HEAD
			} else if ( opFn === '.' ) {

				code = left + opFn + right;

=======
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9
			} else {

				code = left + '.' + opFn + '( ' + right + ' )';

			}

		} else if ( node.isFunctionCall ) {

			const params = [];

			for ( const parameter of node.params ) {

				params.push( this.emitExpression( parameter ) );

			}

<<<<<<< HEAD
			// handle texture lookup function calls in separate branch

			if ( textureLookupFunctions.includes( node.name ) ) {

				code = `${ params[ 0 ] }.sample( ${ params[ 1 ] } )`;

				if ( node.name === 'texture' || node.name === 'texture2D' || node.name === 'texture3D' || node.name === 'textureCube' ) {

					if ( params.length === 3 ) {

						code += `.bias( ${ params[ 2 ] } )`;

					}

				} else if ( node.name === 'textureLod' ) {

					code += `.level( ${ params[ 2 ] } )`;

				} else if ( node.name === 'textureGrad' ) {

					code += `.grad( ${ params[ 2 ] }, ${ params[ 3 ] } )`;

				} else if ( node.name === 'texelFetch' ) {

					code += '.setSampler( false )';

				}

			} else {

				this.addImport( node.name );

				const paramsStr = params.length > 0 ? ' ' + params.join( ', ' ) + ' ' : '';

				code = `${ node.name }(${ paramsStr })`;

			}
=======
			this.addImport( node.name );

			const paramsStr = params.length > 0 ? ' ' + params.join( ', ' ) + ' ' : '';

			code = `${ node.name }(${ paramsStr })`;
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9

		} else if ( node.isReturn ) {

			code = 'return';

			if ( node.value ) {

				code += ' ' + this.emitExpression( node.value );

			}

<<<<<<< HEAD
		} else if ( node.isDiscard ) {

			this.addImport( 'Discard' );

			code = 'Discard()';

		} else if ( node.isBreak ) {

			this.addImport( 'Break' );

			code = 'Break()';

		} else if ( node.isContinue ) {

			this.addImport( 'Continue' );

			code = 'Continue()';

		} else if ( node.isAccessorElements ) {

			code = this.emitExpression( node.object );
=======
		} else if ( node.isAccessorElements ) {

			code = node.property;
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9

			for ( const element of node.elements ) {

				if ( element.isStaticElement ) {

					code += '.' + this.emitExpression( element.value );

				} else if ( element.isDynamicElement ) {

					const value = this.emitExpression( element.value );

					if ( isPrimitive( value ) ) {

						code += `[ ${ value } ]`;

					} else {

						code += `.element( ${ value } )`;

					}

				}

			}

		} else if ( node.isDynamicElement ) {

			code = this.emitExpression( node.value );

		} else if ( node.isStaticElement ) {

			code = this.emitExpression( node.value );

		} else if ( node.isFor ) {

			code = this.emitFor( node );

<<<<<<< HEAD
		} else if ( node.isWhile ) {

			code = this.emitWhile( node );

		} else if ( node.isSwitch ) {

			code = this.emitSwitch( node );

=======
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9
		} else if ( node.isVariableDeclaration ) {

			code = this.emitVariables( node );

		} else if ( node.isUniform ) {

			code = this.emitUniform( node );

<<<<<<< HEAD
		} else if ( node.isVarying ) {

			code = this.emitVarying( node );

=======
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9
		} else if ( node.isTernary ) {

			code = this.emitTernary( node );

		} else if ( node.isConditional ) {

			code = this.emitConditional( node );

<<<<<<< HEAD
		} else if ( node.isUnary && node.expression.isNumber && node.type === '-' ) {

			code = '- ' + node.expression.value;

			if ( node.expression.type !== 'float' ) {

				code = node.expression.type + '( ' + code + ' )';

				this.addImport( node.expression.type );

			}
=======
		} else if ( node.isUnary && node.expression.isNumber ) {

			code = node.type + ' ' + node.expression.value;
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9

		} else if ( node.isUnary ) {

			let type = unaryLib[ node.type ];

<<<<<<< HEAD
			if ( node.hasAssignment ) {

				if ( node.after === false && ( node.type === '++' || node.type === '--' ) ) {

					type += 'Before';

				}
=======
			if ( node.after === false && ( node.type === '++' || node.type === '--' ) ) {

				type += 'Before';
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9

			}

			const exp = this.emitExpression( node.expression );

			if ( isPrimitive( exp ) ) {

				this.addImport( type );

				code = type + '( ' + exp + ' )';

			} else {

				code = exp + '.' + type + '()';

			}

		} else {

			console.warn( 'Unknown node type', node );

		}

		if ( ! code ) code = '/* unknown statement */';

		return code;

	}

	emitBody( body ) {

<<<<<<< HEAD
=======
		this.setLastStatement( null );

>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9
		let code = '';

		this.tab += '\t';

		for ( const statement of body ) {

<<<<<<< HEAD
			code += this.emitExtraLine( statement, body );

			if ( statement.isComment ) {

				code += this.emitComment( statement, body );

				continue;

			}

			if ( this.block && this.block.isSwitchCase ) {

				if ( statement.isBreak ) continue; // skip break statements in switch cases

			}

=======
			code += this.emitExtraLine( statement );
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9
			code += this.tab + this.emitExpression( statement );

			if ( code.slice( - 1 ) !== '}' ) code += ';';

			code += '\n';

<<<<<<< HEAD
=======
			this.setLastStatement( statement );

>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9
		}

		code = code.slice( 0, - 1 ); // remove the last extra line

		this.tab = this.tab.slice( 0, - 1 );

		return code;


	}

	emitTernary( node ) {

		const condStr = this.emitExpression( node.cond );
		const leftStr = this.emitExpression( node.left );
		const rightStr = this.emitExpression( node.right );

		this.addImport( 'select' );

		return `select( ${ condStr }, ${ leftStr }, ${ rightStr } )`;

	}

	emitConditional( node ) {

		const condStr = this.emitExpression( node.cond );
		const bodyStr = this.emitBody( node.body );

		let ifStr = `If( ${ condStr }, () => {

${ bodyStr }

${ this.tab }} )`;

		let current = node;

		while ( current.elseConditional ) {

			const elseBodyStr = this.emitBody( current.elseConditional.body );

			if ( current.elseConditional.cond ) {

				const elseCondStr = this.emitExpression( current.elseConditional.cond );

				ifStr += `.ElseIf( ${ elseCondStr }, () => {

${ elseBodyStr }

${ this.tab }} )`;

			} else {

				ifStr += `.Else( () => {

${ elseBodyStr }

${ this.tab }} )`;

			}

			current = current.elseConditional;


		}

		this.imports.add( 'If' );

		return ifStr;

	}

	emitLoop( node ) {

		const start = this.emitExpression( node.initialization.value );
		const end = this.emitExpression( node.condition.right );

		const name = node.initialization.name;
		const type = node.initialization.type;
		const condition = node.condition.type;
<<<<<<< HEAD
=======
		const update = node.afterthought.type;
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9

		const nameParam = name !== 'i' ? `, name: '${ name }'` : '';
		const typeParam = type !== 'int' ? `, type: '${ type }'` : '';
		const conditionParam = condition !== '<' ? `, condition: '${ condition }'` : '';
<<<<<<< HEAD

		let updateParam = '';

		if ( node.afterthought.isUnary ) {

			if ( node.afterthought.type !== '++' ) {

				updateParam = `, update: '${ node.afterthought.type }'`;

			}

		} else if ( node.afterthought.isOperator ) {

			if ( node.afterthought.right.isAccessor || node.afterthought.right.isNumber ) {

				updateParam = `, update: ${ this.emitExpression( node.afterthought.right ) }`;

			} else {

				updateParam = `, update: ( { i } ) => ${ this.emitExpression( node.afterthought ) }`;

			}

		}
=======
		const updateParam = update !== '++' ? `, update: '${ update }'` : '';
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9

		let loopStr = `Loop( { start: ${ start }, end: ${ end + nameParam + typeParam + conditionParam + updateParam } }, ( { ${ name } } ) => {\n\n`;

		loopStr += this.emitBody( node.body ) + '\n\n';

		loopStr += this.tab + '} )';

		this.imports.add( 'Loop' );

		return loopStr;

	}

<<<<<<< HEAD

	emitSwitch( switchNode ) {

		const discriminantString = this.emitExpression( switchNode.discriminant );

		this.tab += '\t';

		let switchString = `Switch( ${ discriminantString } )\n${ this.tab }`;

		const previousBlock = this.block;

		for ( const switchCase of switchNode.cases ) {

			this.block = switchCase;

			let caseBodyString;

			if ( ! switchCase.isDefault ) {

				const caseConditions = [ ];

				for ( const condition of switchCase.conditions ) {

					caseConditions.push( this.emitExpression( condition ) );

				}

				caseBodyString = this.emitBody( switchCase.body );

				switchString += `.Case( ${ caseConditions.join( ', ' ) }, `;

			} else {

				caseBodyString = this.emitBody( switchCase.body );

				switchString += '.Default( ';

			}

			switchString += `() => {

${ caseBodyString }

${ this.tab }} )`;

		}

		this.block = previousBlock;

		this.tab = this.tab.slice( 0, - 1 );

		this.imports.add( 'Switch' );

		return switchString;

	}

=======
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9
	emitFor( node ) {

		const { initialization, condition, afterthought } = node;

		if ( ( initialization && initialization.isVariableDeclaration && initialization.next === null ) &&
			( condition && condition.left.isAccessor && condition.left.property === initialization.name ) &&
<<<<<<< HEAD
			( afterthought && (
				( afterthought.isUnary && ( initialization.name === afterthought.expression.property ) ) ||
				( afterthought.isOperator && ( initialization.name === afterthought.left.property ) )
			) )
=======
			( afterthought && afterthought.isUnary ) &&
			( initialization.name === afterthought.expression.property )
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9
		) {

			return this.emitLoop( node );

		}

		return this.emitForWhile( node );

	}

	emitForWhile( node ) {

		const initialization = this.emitExpression( node.initialization );
		const condition = this.emitExpression( node.condition );
		const afterthought = this.emitExpression( node.afterthought );

		this.tab += '\t';

		let forStr = '{\n\n' + this.tab + initialization + ';\n\n';
<<<<<<< HEAD
		forStr += `${ this.tab }Loop( ${ condition }, () => {\n\n`;
=======
		forStr += `${ this.tab }While( ${ condition }, () => {\n\n`;
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9

		forStr += this.emitBody( node.body ) + '\n\n';

		forStr += this.tab + '\t' + afterthought + ';\n\n';

		forStr += this.tab + '} )\n\n';

		this.tab = this.tab.slice( 0, - 1 );

		forStr += this.tab + '}';

<<<<<<< HEAD
		this.imports.add( 'Loop' );
=======
		this.imports.add( 'While' );
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9

		return forStr;

	}

<<<<<<< HEAD
	emitWhile( node ) {

		const condition = this.emitExpression( node.condition );

		let whileStr = `Loop( ${ condition }, () => {\n\n`;

		whileStr += this.emitBody( node.body ) + '\n\n';

		whileStr += this.tab + '} )';

		this.imports.add( 'Loop' );

		return whileStr;

	}

=======
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9
	emitVariables( node, isRoot = true ) {

		const { name, type, value, next } = node;

<<<<<<< HEAD
=======
		const valueStr = value ? this.emitExpression( value ) : '';

>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9
		let varStr = isRoot ? 'const ' : '';
		varStr += name;

		if ( value ) {

<<<<<<< HEAD
			let valueStr = this.emitExpression( value );

			if ( value.isNumericExpression ) {

				// convert JS primitive to node

				valueStr = `${ type }( ${ valueStr } )`;

				this.addImport( type );

			}

			varStr += ' = ' + valueStr;

		} else {

			varStr += ` = property( '${ type }' )`;

			this.addImport( 'property' );
=======
			if ( value.isFunctionCall && value.name === type ) {

				varStr += ' = ' + valueStr;

			} else {

				varStr += ` = ${ type }( ${ valueStr } )`;

			}

		} else {

			varStr += ` = ${ type }()`;

		}

		if ( node.immutable === false ) {

			varStr += '.toVar()';
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9

		}

		if ( next ) {

			varStr += ', ' + this.emitVariables( next, false );

		}

<<<<<<< HEAD
=======
		this.addImport( type );

>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9
		return varStr;

	}

<<<<<<< HEAD
	emitVarying( node ) {

		const { name, type } = node;

		this.addImport( 'varying' );
		this.addImport( type );

		return `const ${ name } = varying( ${ type }(), '${ name }' )`;

	}
=======
	/*emitVarying( node ) { }*/
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9

	emitOverloadingFunction( nodes ) {

		const { name } = nodes[ 0 ];

		this.addImport( 'overloadingFn' );

		const prefix = this.iife === false ? 'export ' : '';

<<<<<<< HEAD
		return `${ prefix }const ${ name } = /*@__PURE__*/ overloadingFn( [ ${ nodes.map( node => node.name + '_' + nodes.indexOf( node ) ).join( ', ' ) } ] );\n`;
=======
		return `${ prefix }const ${ name } = /*#__PURE__*/ overloadingFn( [ ${ nodes.map( node => node.name + '_' + nodes.indexOf( node ) ).join( ', ' ) } ] );\n`;
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9

	}

	emitFunction( node ) {

		const { name, type } = node;

<<<<<<< HEAD
=======
		this._currentProperties = { name: node };

>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9
		const params = [];
		const inputs = [];
		const mutableParams = [];

		let hasPointer = false;

		for ( const param of node.params ) {

<<<<<<< HEAD
			let name = param.name;

			if ( param.linker.assignments.length > 0 ) {
=======
			let str = `{ name: '${ param.name }', type: '${ param.type }'`;

			let name = param.name;

			if ( param.immutable === false && ( param.qualifier !== 'inout' && param.qualifier !== 'out' ) ) {
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9

				name = name + '_immutable';

				mutableParams.push( param );

			}

			if ( param.qualifier ) {

				if ( param.qualifier === 'inout' || param.qualifier === 'out' ) {

					hasPointer = true;

				}

<<<<<<< HEAD
			}

			inputs.push( param.name + ': \'' + param.type + '\'' );
			params.push( name );

=======
				str += ', qualifier: \'' + param.qualifier + '\'';

			}

			inputs.push( str + ' }' );
			params.push( name );

			this._currentProperties[ name ] = param;

>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9
		}

		for ( const param of mutableParams ) {

<<<<<<< HEAD
			const mutableParam = new VariableDeclaration( param.type, param.name, new Accessor( param.name + '_immutable' ), null, true );
			mutableParam.parent = param.parent; // link to the original node
			mutableParam.linker.assignments.push( mutableParam );

			node.body.unshift( mutableParam );
=======
			node.body.unshift( new VariableDeclaration( param.type, param.name, new Accessor( param.name + '_immutable' ) ) );
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9

		}

		const paramsStr = params.length > 0 ? ' [ ' + params.join( ', ' ) + ' ] ' : '';
		const bodyStr = this.emitBody( node.body );

		let fnName = name;
		let overloadingNodes = null;

		if ( this.overloadings.has( name ) ) {

			const overloadings = this.overloadings.get( name );

			if ( overloadings.length > 1 ) {

				const index = overloadings.indexOf( node );

				fnName += '_' + index;

				if ( index === overloadings.length - 1 ) {

					overloadingNodes = overloadings;

				}

			}

		}

		const prefix = this.iife === false ? 'export ' : '';

<<<<<<< HEAD
		let funcStr = `${ prefix }const ${ fnName } = /*@__PURE__*/ Fn( (${ paramsStr }) => {

${ bodyStr }

${ this.tab }}`;

		if ( node.layout !== false && hasPointer === false ) {

			funcStr += ', { ' + inputs.join( ', ' ) + ', return: \'' + type + '\' }';

		}

		funcStr += ' );\n';
=======
		let funcStr = `${ prefix }const ${ fnName } = /*#__PURE__*/ Fn( (${ paramsStr }) => {

${ bodyStr }

${ this.tab }} )`;

		const layoutInput = inputs.length > 0 ? '\n\t\t' + this.tab + inputs.join( ',\n\t\t' + this.tab ) + '\n\t' + this.tab : '';

		if ( node.layout !== false && hasPointer === false ) {

			const uniqueName = this.uniqueNames ? fnName + '_' + Math.random().toString( 36 ).slice( 2 ) : fnName;

			funcStr += `.setLayout( {
${ this.tab }\tname: '${ uniqueName }',
${ this.tab }\ttype: '${ type }',
${ this.tab }\tinputs: [${ layoutInput }]
${ this.tab }} )`;

		}

		funcStr += ';\n';
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9

		this.imports.add( 'Fn' );

		this.global.add( node.name );

		if ( overloadingNodes !== null ) {

			funcStr += '\n' + this.emitOverloadingFunction( overloadingNodes );

		}

		return funcStr;

	}

<<<<<<< HEAD
	emitComment( statement, body ) {

		const index = body.indexOf( statement );
		const previous = body[ index - 1 ];
		const next = body[ index + 1 ];

		let output = '';

		if ( previous && isExpression( previous ) ) {

			output += '\n';

		}

		output += this.tab + statement.comment.replace( /\n/g, '\n' + this.tab ) + '\n';

		if ( next && isExpression( next ) ) {

			output += '\n';

		}

		return output;

	}

	emitExtraLine( statement, body ) {

		const index = body.indexOf( statement );
		const previous = body[ index - 1 ];

		if ( previous === undefined ) return '';

		if ( statement.isReturn ) return '\n';

		const lastExp = isExpression( previous );
=======
	setLastStatement( statement ) {

		this._lastStatement = statement;

	}

	emitExtraLine( statement ) {

		const last = this._lastStatement;
		if ( last === null ) return '';

		if ( statement.isReturn ) return '\n';

		const isExpression = ( st ) => st.isFunctionDeclaration !== true && st.isFor !== true && st.isConditional !== true;
		const lastExp = isExpression( last );
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9
		const currExp = isExpression( statement );

		if ( lastExp !== currExp || ( ! lastExp && ! currExp ) ) return '\n';

		return '';

	}

	emit( ast ) {

		let code = '\n';

		if ( this.iife ) this.tab += '\t';

		const overloadings = this.overloadings;

		for ( const statement of ast.body ) {

			if ( statement.isFunctionDeclaration ) {

				if ( overloadings.has( statement.name ) === false ) {

					overloadings.set( statement.name, [] );

				}

				overloadings.get( statement.name ).push( statement );

			}

		}

		for ( const statement of ast.body ) {

<<<<<<< HEAD
			code += this.emitExtraLine( statement, ast.body );

			if ( statement.isComment ) {

				code += this.emitComment( statement, ast.body );

				continue;

			}
=======
			code += this.emitExtraLine( statement );
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9

			if ( statement.isFunctionDeclaration ) {

				code += this.tab + this.emitFunction( statement );

			} else {

				code += this.tab + this.emitExpression( statement ) + ';\n';

			}

<<<<<<< HEAD
=======
			this.setLastStatement( statement );

>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9
		}

		const imports = [ ...this.imports ];
		const exports = [ ...this.global ];

<<<<<<< HEAD
		let header = '// Three.js Transpiler r' + REVISION + '\n\n';
=======
		let header = '// Three.js Transpiler r' + THREE.REVISION + '\n\n';
>>>>>>> 1b08ea1de21880f3fba2a757661b8baef5d934b9
		let footer = '';

		if ( this.iife ) {

			header += '( function ( TSL, uniforms ) {\n\n';

			header += imports.length > 0 ? '\tconst { ' + imports.join( ', ' ) + ' } = TSL;\n' : '';
			footer += exports.length > 0 ? '\treturn { ' + exports.join( ', ' ) + ' };\n' : '';

			footer += '\n} );';

		} else {

			header += imports.length > 0 ? 'import { ' + imports.join( ', ' ) + ' } from \'three/tsl\';\n' : '';

		}

		return header + code + footer;

	}

}

export default TSLEncoder;
